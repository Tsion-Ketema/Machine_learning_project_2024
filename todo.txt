Find a way to have one main entry point then 2 options train a model or run the cup_blind_test.
1. train a model 
 1.1:-cup/monk
   1.1.1 cup--->performing mnamn belo entire steps yeketlal
   1.1.2 monk
      1.1.1.1 monk-1-->performing mnamn belo entire steps yeketlal
      1.1.1.2 monk-2--->performing mnamn belo entire steps yeketlal
      1.1.1.3.monk-3--->performing mnamn belo entire steps yeketlal
2. cup_blind_test
  1.1 choose a model? (models are presented based on their rank).
      1.1 model_1
      1.2 model_2
      1.3 model_3

Prepare two folders that holds one our result/the one the tester uses.



so from the task function we passed this to the train model i neural network
model.train(X_tr, Y_tr, X_val=X_vl, y_val=Y_vl)

it refers the indexes or the data in 1 fold this two X_tr, Y_tr represents features and labels of the training indexes in 1 specific fold right ant the this two X_val=X_vl, y_val=Y_vl) referes the validation loss ----> correct me if i am wrong but when it comes to the trainv it makes the validation loss None does it means it is making them non or when we pass the data using the model.train it is getting some value in it

def train(self, X, y, X_val=None, y_val=None):
        """Train the neural network with the provided data."""
        for epoch in range(self.epochs):
            self.forward(X)
            grads_w, grads_b = self.backward(X, y)

            for i in range(len(self.weights)):
                self.velocity_w[i] = self.momentum * \
                    self.velocity_w[i] - self.learning_rate * grads_w[i]
                self.velocity_b[i] = self.momentum * \
                    self.velocity_b[i] - self.learning_rate * grads_b[i]
                self.weights[i] += self.velocity_w[i]
                self.biases[i] += self.velocity_b[i]

            # Store train loss and accuracy
            train_loss = self.compute_loss(y, self.forward(X))
            self.train_losses.append(train_loss)

            if self.task_type == 'classification':
                train_acc = self._compute_accuracy(y, self.forward(X))
                self.train_accuracies.append(train_acc)

            if X_val is not None and y_val is not None:
                val_loss = self.compute_loss(y_val, self.forward(X_val))
                self.val_losses.append(val_loss)

                if self.task_type == 'classification':
                    val_acc = self._compute_accuracy(
                        y_val, self.forward(X_val))
                    if self.val_accuracies is not None:
                        self.val_accuracies.append(val_acc)